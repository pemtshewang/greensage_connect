diff --git a/node_modules/paho-mqtt/paho-mqtt.js b/node_modules/paho-mqtt/paho-mqtt.js
index 9ca3d37..f5e0769 100644
--- a/node_modules/paho-mqtt/paho-mqtt.js
+++ b/node_modules/paho-mqtt/paho-mqtt.js
@@ -61,20 +61,20 @@ client.onMessageArrived = onMessageArrived;
 client.connect({onSuccess:onConnect});
 
 function onConnect() {
-  // Once a connection has been made, make a subscription and send a message.
-  console.log("onConnect");
-  client.subscribe("/World");
-  var message = new Paho.MQTT.Message("Hello");
-  message.destinationName = "/World";
-  client.send(message);
+	// Once a connection has been made, make a subscription and send a message.
+	console.log("onConnect");
+	client.subscribe("/World");
+	var message = new Paho.MQTT.Message("Hello");
+	message.destinationName = "/World";
+	client.send(message);
 };
 function onConnectionLost(responseObject) {
-  if (responseObject.errorCode !== 0)
+	if (responseObject.errorCode !== 0)
 	console.log("onConnectionLost:"+responseObject.errorMessage);
 };
 function onMessageArrived(message) {
-  console.log("onMessageArrived:"+message.payloadString);
-  client.disconnect();
+	console.log("onMessageArrived:"+message.payloadString);
+	client.disconnect();
 };
  * </pre></code>
  * @namespace Paho
@@ -82,11 +82,11 @@ function onMessageArrived(message) {
 
 /* jshint shadow:true */
 (function ExportLibrary(root, factory) {
-	if(typeof exports === "object" && typeof module === "object"){
+	if (typeof exports === "object" && typeof module === "object") {
 		module.exports = factory();
-	} else if (typeof define === "function" && define.amd){
+	} else if (typeof define === "function" && define.amd) {
 		define(factory);
-	} else if (typeof exports === "object"){
+	} else if (typeof exports === "object") {
 		exports = factory();
 	} else {
 		//if (typeof root.Paho === "undefined"){
@@ -94,27 +94,27 @@ function onMessageArrived(message) {
 		//}
 		root.Paho = factory();
 	}
-})(this, function LibraryFactory(){
+})(this, function LibraryFactory() {
 
 
 	var PahoMQTT = (function (global) {
 
-	// Private variables below, these are only visible inside the function closure
-	// which is used to define the module.
-	var version = "@VERSION@-@BUILDLEVEL@";
+		// Private variables below, these are only visible inside the function closure
+		// which is used to define the module.
+		var version = "@VERSION@-@BUILDLEVEL@";
 
-	/**
-	 * @private
-	 */
-	var localStorage = global.localStorage || (function () {
-		var data = {};
+		/**
+		 * @private
+		 */
+		var localStorage = global.localStorage || (function () {
+			var data = {};
 
-		return {
-			setItem: function (key, item) { data[key] = item; },
-			getItem: function (key) { return data[key]; },
-			removeItem: function (key) { delete data[key]; },
-		};
-	})();
+			return {
+				setItem: function (key, item) { data[key] = item; },
+				getItem: function (key) { return data[key]; },
+				removeItem: function (key) { delete data[key]; },
+			};
+		})();
 
 		/**
 	 * Unique message type identifiers, with associated
@@ -151,7 +151,7 @@ function onMessageArrived(message) {
 	 * @throws {Error} Invalid option parameter found.
 	 * @private
 	 */
-		var validate = function(obj, keys) {
+		var validate = function (obj, keys) {
 			for (var key in obj) {
 				if (obj.hasOwnProperty(key)) {
 					if (keys.hasOwnProperty(key)) {
@@ -161,7 +161,7 @@ function onMessageArrived(message) {
 						var errorStr = "Unknown property, " + key + ". Valid properties are:";
 						for (var validKey in keys)
 							if (keys.hasOwnProperty(validKey))
-								errorStr = errorStr+" "+validKey;
+								errorStr = errorStr + " " + validKey;
 						throw new Error(errorStr);
 					}
 				}
@@ -188,55 +188,55 @@ function onMessageArrived(message) {
 	 * @private
 	 */
 		var ERROR = {
-			OK: {code:0, text:"AMQJSC0000I OK."},
-			CONNECT_TIMEOUT: {code:1, text:"AMQJSC0001E Connect timed out."},
-			SUBSCRIBE_TIMEOUT: {code:2, text:"AMQJS0002E Subscribe timed out."},
-			UNSUBSCRIBE_TIMEOUT: {code:3, text:"AMQJS0003E Unsubscribe timed out."},
-			PING_TIMEOUT: {code:4, text:"AMQJS0004E Ping timed out."},
-			INTERNAL_ERROR: {code:5, text:"AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}"},
-			CONNACK_RETURNCODE: {code:6, text:"AMQJS0006E Bad Connack return code:{0} {1}."},
-			SOCKET_ERROR: {code:7, text:"AMQJS0007E Socket error:{0}."},
-			SOCKET_CLOSE: {code:8, text:"AMQJS0008I Socket closed."},
-			MALFORMED_UTF: {code:9, text:"AMQJS0009E Malformed UTF data:{0} {1} {2}."},
-			UNSUPPORTED: {code:10, text:"AMQJS0010E {0} is not supported by this browser."},
-			INVALID_STATE: {code:11, text:"AMQJS0011E Invalid state {0}."},
-			INVALID_TYPE: {code:12, text:"AMQJS0012E Invalid type {0} for {1}."},
-			INVALID_ARGUMENT: {code:13, text:"AMQJS0013E Invalid argument {0} for {1}."},
-			UNSUPPORTED_OPERATION: {code:14, text:"AMQJS0014E Unsupported operation."},
-			INVALID_STORED_DATA: {code:15, text:"AMQJS0015E Invalid data in local storage key={0} value={1}."},
-			INVALID_MQTT_MESSAGE_TYPE: {code:16, text:"AMQJS0016E Invalid MQTT message type {0}."},
-			MALFORMED_UNICODE: {code:17, text:"AMQJS0017E Malformed Unicode string:{0} {1}."},
-			BUFFER_FULL: {code:18, text:"AMQJS0018E Message buffer is full, maximum buffer size: {0}."},
+			OK: { code: 0, text: "AMQJSC0000I OK." },
+			CONNECT_TIMEOUT: { code: 1, text: "AMQJSC0001E Connect timed out." },
+			SUBSCRIBE_TIMEOUT: { code: 2, text: "AMQJS0002E Subscribe timed out." },
+			UNSUBSCRIBE_TIMEOUT: { code: 3, text: "AMQJS0003E Unsubscribe timed out." },
+			PING_TIMEOUT: { code: 4, text: "AMQJS0004E Ping timed out." },
+			INTERNAL_ERROR: { code: 5, text: "AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}" },
+			CONNACK_RETURNCODE: { code: 6, text: "AMQJS0006E Bad Connack return code:{0} {1}." },
+			SOCKET_ERROR: { code: 7, text: "AMQJS0007E Socket error:{0}." },
+			SOCKET_CLOSE: { code: 8, text: "AMQJS0008I Socket closed." },
+			MALFORMED_UTF: { code: 9, text: "AMQJS0009E Malformed UTF data:{0} {1} {2}." },
+			UNSUPPORTED: { code: 10, text: "AMQJS0010E {0} is not supported by this browser." },
+			INVALID_STATE: { code: 11, text: "AMQJS0011E Invalid state {0}." },
+			INVALID_TYPE: { code: 12, text: "AMQJS0012E Invalid type {0} for {1}." },
+			INVALID_ARGUMENT: { code: 13, text: "AMQJS0013E Invalid argument {0} for {1}." },
+			UNSUPPORTED_OPERATION: { code: 14, text: "AMQJS0014E Unsupported operation." },
+			INVALID_STORED_DATA: { code: 15, text: "AMQJS0015E Invalid data in local storage key={0} value={1}." },
+			INVALID_MQTT_MESSAGE_TYPE: { code: 16, text: "AMQJS0016E Invalid MQTT message type {0}." },
+			MALFORMED_UNICODE: { code: 17, text: "AMQJS0017E Malformed Unicode string:{0} {1}." },
+			BUFFER_FULL: { code: 18, text: "AMQJS0018E Message buffer is full, maximum buffer size: {0}." },
 		};
 
 		/** CONNACK RC Meaning. */
 		var CONNACK_RC = {
-			0:"Connection Accepted",
-			1:"Connection Refused: unacceptable protocol version",
-			2:"Connection Refused: identifier rejected",
-			3:"Connection Refused: server unavailable",
-			4:"Connection Refused: bad user name or password",
-			5:"Connection Refused: not authorized"
+			0: "Connection Accepted",
+			1: "Connection Refused: unacceptable protocol version",
+			2: "Connection Refused: identifier rejected",
+			3: "Connection Refused: server unavailable",
+			4: "Connection Refused: bad user name or password",
+			5: "Connection Refused: not authorized"
 		};
 
-	/**
-	 * Format an error message text.
-	 * @private
-	 * @param {error} ERROR value above.
-	 * @param {substitutions} [array] substituted into the text.
-	 * @return the text with the substitutions made.
-	 */
-		var format = function(error, substitutions) {
+		/**
+		 * Format an error message text.
+		 * @private
+		 * @param {error} ERROR value above.
+		 * @param {substitutions} [array] substituted into the text.
+		 * @return the text with the substitutions made.
+		 */
+		var format = function (error, substitutions) {
 			var text = error.text;
 			if (substitutions) {
-				var field,start;
-				for (var i=0; i<substitutions.length; i++) {
-					field = "{"+i+"}";
+				var field, start;
+				for (var i = 0; i < substitutions.length; i++) {
+					field = "{" + i + "}";
 					start = text.indexOf(field);
-					if(start > 0) {
-						var part1 = text.substring(0,start);
-						var part2 = text.substring(start+field.length);
-						text = part1+substitutions[i]+part2;
+					if (start > 0) {
+						var part1 = text.substring(0, start);
+						var part2 = text.substring(start + field.length);
+						text = part1 + substitutions[i] + part2;
 					}
 				}
 			}
@@ -244,9 +244,9 @@ function onMessageArrived(message) {
 		};
 
 		//MQTT protocol and version          6    M    Q    I    s    d    p    3
-		var MqttProtoIdentifierv3 = [0x00,0x06,0x4d,0x51,0x49,0x73,0x64,0x70,0x03];
+		var MqttProtoIdentifierv3 = [0x00, 0x06, 0x4d, 0x51, 0x49, 0x73, 0x64, 0x70, 0x03];
 		//MQTT proto/version for 311         4    M    Q    T    T    4
-		var MqttProtoIdentifierv4 = [0x00,0x04,0x4d,0x51,0x54,0x54,0x04];
+		var MqttProtoIdentifierv4 = [0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04];
 
 		/**
 	 * Construct an MQTT wire protocol message.
@@ -281,8 +281,8 @@ function onMessageArrived(message) {
 			}
 		};
 
-		WireMessage.prototype.encode = function() {
-		// Compute the first byte of the fixed header
+		WireMessage.prototype.encode = function () {
+			// Compute the first byte of the fixed header
 			var first = ((this.type & 0x0f) << 4);
 
 			/*
@@ -299,75 +299,75 @@ function onMessageArrived(message) {
 			if (this.messageIdentifier !== undefined)
 				remLength += 2;
 
-			switch(this.type) {
-			// If this a Connect then we need to include 12 bytes for its header
-			case MESSAGE_TYPE.CONNECT:
-				switch(this.mqttVersion) {
-				case 3:
-					remLength += MqttProtoIdentifierv3.length + 3;
+			switch (this.type) {
+				// If this a Connect then we need to include 12 bytes for its header
+				case MESSAGE_TYPE.CONNECT:
+					switch (this.mqttVersion) {
+						case 3:
+							remLength += MqttProtoIdentifierv3.length + 3;
+							break;
+						case 4:
+							remLength += MqttProtoIdentifierv4.length + 3;
+							break;
+					}
+
+					remLength += UTF8Length(this.clientId) + 2;
+					if (this.willMessage !== undefined) {
+						remLength += UTF8Length(this.willMessage.destinationName) + 2;
+						// Will message is always a string, sent as UTF-8 characters with a preceding length.
+						willMessagePayloadBytes = this.willMessage.payloadBytes;
+						if (!(willMessagePayloadBytes instanceof Uint8Array))
+							willMessagePayloadBytes = new Uint8Array(payloadBytes);
+						remLength += willMessagePayloadBytes.byteLength + 2;
+					}
+					if (this.userName !== undefined)
+						remLength += UTF8Length(this.userName) + 2;
+					if (this.password !== undefined)
+						remLength += UTF8Length(this.password) + 2;
 					break;
-				case 4:
-					remLength += MqttProtoIdentifierv4.length + 3;
+
+				// Subscribe, Unsubscribe can both contain topic strings
+				case MESSAGE_TYPE.SUBSCRIBE:
+					first |= 0x02; // Qos = 1;
+					for (var i = 0; i < this.topics.length; i++) {
+						topicStrLength[i] = UTF8Length(this.topics[i]);
+						remLength += topicStrLength[i] + 2;
+					}
+					remLength += this.requestedQos.length; // 1 byte for each topic's Qos
+					// QoS on Subscribe only
 					break;
-				}
 
-				remLength += UTF8Length(this.clientId) + 2;
-				if (this.willMessage !== undefined) {
-					remLength += UTF8Length(this.willMessage.destinationName) + 2;
-					// Will message is always a string, sent as UTF-8 characters with a preceding length.
-					willMessagePayloadBytes = this.willMessage.payloadBytes;
-					if (!(willMessagePayloadBytes instanceof Uint8Array))
-						willMessagePayloadBytes = new Uint8Array(payloadBytes);
-					remLength += willMessagePayloadBytes.byteLength +2;
-				}
-				if (this.userName !== undefined)
-					remLength += UTF8Length(this.userName) + 2;
-				if (this.password !== undefined)
-					remLength += UTF8Length(this.password) + 2;
-				break;
-
-			// Subscribe, Unsubscribe can both contain topic strings
-			case MESSAGE_TYPE.SUBSCRIBE:
-				first |= 0x02; // Qos = 1;
-				for ( var i = 0; i < this.topics.length; i++) {
-					topicStrLength[i] = UTF8Length(this.topics[i]);
-					remLength += topicStrLength[i] + 2;
-				}
-				remLength += this.requestedQos.length; // 1 byte for each topic's Qos
-				// QoS on Subscribe only
-				break;
-
-			case MESSAGE_TYPE.UNSUBSCRIBE:
-				first |= 0x02; // Qos = 1;
-				for ( var i = 0; i < this.topics.length; i++) {
-					topicStrLength[i] = UTF8Length(this.topics[i]);
-					remLength += topicStrLength[i] + 2;
-				}
-				break;
-
-			case MESSAGE_TYPE.PUBREL:
-				first |= 0x02; // Qos = 1;
-				break;
-
-			case MESSAGE_TYPE.PUBLISH:
-				if (this.payloadMessage.duplicate) first |= 0x08;
-				first  = first |= (this.payloadMessage.qos << 1);
-				if (this.payloadMessage.retained) first |= 0x01;
-				destinationNameLength = UTF8Length(this.payloadMessage.destinationName);
-				remLength += destinationNameLength + 2;
-				var payloadBytes = this.payloadMessage.payloadBytes;
-				remLength += payloadBytes.byteLength;
-				if (payloadBytes instanceof ArrayBuffer)
-					payloadBytes = new Uint8Array(payloadBytes);
-				else if (!(payloadBytes instanceof Uint8Array))
-					payloadBytes = new Uint8Array(payloadBytes.buffer);
-				break;
-
-			case MESSAGE_TYPE.DISCONNECT:
-				break;
-
-			default:
-				break;
+				case MESSAGE_TYPE.UNSUBSCRIBE:
+					first |= 0x02; // Qos = 1;
+					for (var i = 0; i < this.topics.length; i++) {
+						topicStrLength[i] = UTF8Length(this.topics[i]);
+						remLength += topicStrLength[i] + 2;
+					}
+					break;
+
+				case MESSAGE_TYPE.PUBREL:
+					first |= 0x02; // Qos = 1;
+					break;
+
+				case MESSAGE_TYPE.PUBLISH:
+					if (this.payloadMessage.duplicate) first |= 0x08;
+					first = first |= (this.payloadMessage.qos << 1);
+					if (this.payloadMessage.retained) first |= 0x01;
+					destinationNameLength = UTF8Length(this.payloadMessage.destinationName);
+					remLength += destinationNameLength + 2;
+					var payloadBytes = this.payloadMessage.payloadBytes;
+					remLength += payloadBytes.byteLength;
+					if (payloadBytes instanceof ArrayBuffer)
+						payloadBytes = new Uint8Array(payloadBytes);
+					else if (!(payloadBytes instanceof Uint8Array))
+						payloadBytes = new Uint8Array(payloadBytes.buffer);
+					break;
+
+				case MESSAGE_TYPE.DISCONNECT:
+					break;
+
+				default:
+					break;
 			}
 
 			// Now we can allocate a buffer for the message
@@ -379,7 +379,7 @@ function onMessageArrived(message) {
 
 			//Write the fixed header into the buffer
 			byteStream[0] = first;
-			byteStream.set(mbi,1);
+			byteStream.set(mbi, 1);
 
 			// If this is a PUBLISH then the variable header starts with a topic
 			if (this.type == MESSAGE_TYPE.PUBLISH)
@@ -388,21 +388,21 @@ function onMessageArrived(message) {
 
 			else if (this.type == MESSAGE_TYPE.CONNECT) {
 				switch (this.mqttVersion) {
-				case 3:
-					byteStream.set(MqttProtoIdentifierv3, pos);
-					pos += MqttProtoIdentifierv3.length;
-					break;
-				case 4:
-					byteStream.set(MqttProtoIdentifierv4, pos);
-					pos += MqttProtoIdentifierv4.length;
-					break;
+					case 3:
+						byteStream.set(MqttProtoIdentifierv3, pos);
+						pos += MqttProtoIdentifierv3.length;
+						break;
+					case 4:
+						byteStream.set(MqttProtoIdentifierv4, pos);
+						pos += MqttProtoIdentifierv4.length;
+						break;
 				}
 				var connectFlags = 0;
 				if (this.cleanSession)
 					connectFlags = 0x02;
-				if (this.willMessage !== undefined ) {
+				if (this.willMessage !== undefined) {
 					connectFlags |= 0x04;
-					connectFlags |= (this.willMessage.qos<<3);
+					connectFlags |= (this.willMessage.qos << 3);
 					if (this.willMessage.retained) {
 						connectFlags |= 0x20;
 					}
@@ -412,62 +412,62 @@ function onMessageArrived(message) {
 				if (this.password !== undefined)
 					connectFlags |= 0x40;
 				byteStream[pos++] = connectFlags;
-				pos = writeUint16 (this.keepAliveInterval, byteStream, pos);
+				pos = writeUint16(this.keepAliveInterval, byteStream, pos);
 			}
 
 			// Output the messageIdentifier - if there is one
 			if (this.messageIdentifier !== undefined)
-				pos = writeUint16 (this.messageIdentifier, byteStream, pos);
+				pos = writeUint16(this.messageIdentifier, byteStream, pos);
 
-			switch(this.type) {
-			case MESSAGE_TYPE.CONNECT:
-				pos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);
-				if (this.willMessage !== undefined) {
-					pos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);
-					pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);
-					byteStream.set(willMessagePayloadBytes, pos);
-					pos += willMessagePayloadBytes.byteLength;
+			switch (this.type) {
+				case MESSAGE_TYPE.CONNECT:
+					pos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);
+					if (this.willMessage !== undefined) {
+						pos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);
+						pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);
+						byteStream.set(willMessagePayloadBytes, pos);
+						pos += willMessagePayloadBytes.byteLength;
 
-				}
-				if (this.userName !== undefined)
-					pos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);
-				if (this.password !== undefined)
-					pos = writeString(this.password, UTF8Length(this.password), byteStream, pos);
-				break;
+					}
+					if (this.userName !== undefined)
+						pos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);
+					if (this.password !== undefined)
+						pos = writeString(this.password, UTF8Length(this.password), byteStream, pos);
+					break;
 
-			case MESSAGE_TYPE.PUBLISH:
-				// PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.
-				byteStream.set(payloadBytes, pos);
+				case MESSAGE_TYPE.PUBLISH:
+					// PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.
+					byteStream.set(payloadBytes, pos);
 
-				break;
+					break;
 
 				//    	    case MESSAGE_TYPE.PUBREC:
 				//    	    case MESSAGE_TYPE.PUBREL:
 				//    	    case MESSAGE_TYPE.PUBCOMP:
 				//    	    	break;
 
-			case MESSAGE_TYPE.SUBSCRIBE:
-				// SUBSCRIBE has a list of topic strings and request QoS
-				for (var i=0; i<this.topics.length; i++) {
-					pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);
-					byteStream[pos++] = this.requestedQos[i];
-				}
-				break;
+				case MESSAGE_TYPE.SUBSCRIBE:
+					// SUBSCRIBE has a list of topic strings and request QoS
+					for (var i = 0; i < this.topics.length; i++) {
+						pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);
+						byteStream[pos++] = this.requestedQos[i];
+					}
+					break;
 
-			case MESSAGE_TYPE.UNSUBSCRIBE:
-				// UNSUBSCRIBE has a list of topic strings
-				for (var i=0; i<this.topics.length; i++)
-					pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);
-				break;
+				case MESSAGE_TYPE.UNSUBSCRIBE:
+					// UNSUBSCRIBE has a list of topic strings
+					for (var i = 0; i < this.topics.length; i++)
+						pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);
+					break;
 
-			default:
+				default:
 				// Do nothing.
 			}
 
 			return buffer;
 		};
 
-		function decodeMessage(input,pos) {
+		function decodeMessage(input, pos) {
 			var startingPos = pos;
 			var first = input[pos];
 			var type = first >> 4;
@@ -482,69 +482,69 @@ function onMessageArrived(message) {
 			var multiplier = 1;
 			do {
 				if (pos == input.length) {
-					return [null,startingPos];
+					return [null, startingPos];
 				}
 				digit = input[pos++];
 				remLength += ((digit & 0x7F) * multiplier);
 				multiplier *= 128;
 			} while ((digit & 0x80) !== 0);
 
-			var endPos = pos+remLength;
+			var endPos = pos + remLength;
 			if (endPos > input.length) {
-				return [null,startingPos];
+				return [null, startingPos];
 			}
 
 			var wireMessage = new WireMessage(type);
-			switch(type) {
-			case MESSAGE_TYPE.CONNACK:
-				var connectAcknowledgeFlags = input[pos++];
-				if (connectAcknowledgeFlags & 0x01)
-					wireMessage.sessionPresent = true;
-				wireMessage.returnCode = input[pos++];
-				break;
-
-			case MESSAGE_TYPE.PUBLISH:
-				var qos = (messageInfo >> 1) & 0x03;
-
-				var len = readUint16(input, pos);
-				pos += 2;
-				var topicName = parseUTF8(input, pos, len);
-				pos += len;
-				// If QoS 1 or 2 there will be a messageIdentifier
-				if (qos > 0) {
+			switch (type) {
+				case MESSAGE_TYPE.CONNACK:
+					var connectAcknowledgeFlags = input[pos++];
+					if (connectAcknowledgeFlags & 0x01)
+						wireMessage.sessionPresent = true;
+					wireMessage.returnCode = input[pos++];
+					break;
+
+				case MESSAGE_TYPE.PUBLISH:
+					var qos = (messageInfo >> 1) & 0x03;
+
+					var len = readUint16(input, pos);
+					pos += 2;
+					var topicName = parseUTF8(input, pos, len);
+					pos += len;
+					// If QoS 1 or 2 there will be a messageIdentifier
+					if (qos > 0) {
+						wireMessage.messageIdentifier = readUint16(input, pos);
+						pos += 2;
+					}
+
+					var message = new Message(input.subarray(pos, endPos));
+					if ((messageInfo & 0x01) == 0x01)
+						message.retained = true;
+					if ((messageInfo & 0x08) == 0x08)
+						message.duplicate = true;
+					message.qos = qos;
+					message.destinationName = topicName;
+					wireMessage.payloadMessage = message;
+					break;
+
+				case MESSAGE_TYPE.PUBACK:
+				case MESSAGE_TYPE.PUBREC:
+				case MESSAGE_TYPE.PUBREL:
+				case MESSAGE_TYPE.PUBCOMP:
+				case MESSAGE_TYPE.UNSUBACK:
+					wireMessage.messageIdentifier = readUint16(input, pos);
+					break;
+
+				case MESSAGE_TYPE.SUBACK:
 					wireMessage.messageIdentifier = readUint16(input, pos);
 					pos += 2;
-				}
+					wireMessage.returnCode = input.subarray(pos, endPos);
+					break;
 
-				var message = new Message(input.subarray(pos, endPos));
-				if ((messageInfo & 0x01) == 0x01)
-					message.retained = true;
-				if ((messageInfo & 0x08) == 0x08)
-					message.duplicate =  true;
-				message.qos = qos;
-				message.destinationName = topicName;
-				wireMessage.payloadMessage = message;
-				break;
-
-			case  MESSAGE_TYPE.PUBACK:
-			case  MESSAGE_TYPE.PUBREC:
-			case  MESSAGE_TYPE.PUBREL:
-			case  MESSAGE_TYPE.PUBCOMP:
-			case  MESSAGE_TYPE.UNSUBACK:
-				wireMessage.messageIdentifier = readUint16(input, pos);
-				break;
-
-			case  MESSAGE_TYPE.SUBACK:
-				wireMessage.messageIdentifier = readUint16(input, pos);
-				pos += 2;
-				wireMessage.returnCode = input.subarray(pos, endPos);
-				break;
-
-			default:
-				break;
+				default:
+					break;
 			}
 
-			return [wireMessage,endPos];
+			return [wireMessage, endPos];
 		}
 
 		function writeUint16(input, buffer, offset) {
@@ -560,7 +560,7 @@ function onMessageArrived(message) {
 		}
 
 		function readUint16(buffer, offset) {
-			return 256*buffer[offset] + buffer[offset+1];
+			return 256 * buffer[offset] + buffer[offset + 1];
 		}
 
 		/**
@@ -578,7 +578,7 @@ function onMessageArrived(message) {
 					digit |= 0x80;
 				}
 				output[numBytes++] = digit;
-			} while ( (number > 0) && (numBytes<4) );
+			} while ((number > 0) && (numBytes < 4));
 
 			return output;
 		}
@@ -589,21 +589,18 @@ function onMessageArrived(message) {
 	 */
 		function UTF8Length(input) {
 			var output = 0;
-			for (var i = 0; i<input.length; i++)
-			{
+			for (var i = 0; i < input.length; i++) {
 				var charCode = input.charCodeAt(i);
-				if (charCode > 0x7FF)
-				{
+				if (charCode > 0x7FF) {
 					// Surrogate pair means its a 4 byte character
-					if (0xD800 <= charCode && charCode <= 0xDBFF)
-					{
+					if (0xD800 <= charCode && charCode <= 0xDBFF) {
 						i++;
 						output++;
 					}
-					output +=3;
+					output += 3;
 				}
 				else if (charCode > 0x7F)
-					output +=2;
+					output += 2;
 				else
 					output++;
 			}
@@ -616,7 +613,7 @@ function onMessageArrived(message) {
 	 */
 		function stringToUTF8(input, output, start) {
 			var pos = start;
-			for (var i = 0; i<input.length; i++) {
+			for (var i = 0; i < input.length; i++) {
 				var charCode = input.charCodeAt(i);
 
 				// Check for a surrogate pair.
@@ -625,24 +622,24 @@ function onMessageArrived(message) {
 					if (isNaN(lowCharCode)) {
 						throw new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));
 					}
-					charCode = ((charCode - 0xD800)<<10) + (lowCharCode - 0xDC00) + 0x10000;
+					charCode = ((charCode - 0xD800) << 10) + (lowCharCode - 0xDC00) + 0x10000;
 
 				}
 
 				if (charCode <= 0x7F) {
 					output[pos++] = charCode;
 				} else if (charCode <= 0x7FF) {
-					output[pos++] = charCode>>6  & 0x1F | 0xC0;
-					output[pos++] = charCode     & 0x3F | 0x80;
+					output[pos++] = charCode >> 6 & 0x1F | 0xC0;
+					output[pos++] = charCode & 0x3F | 0x80;
 				} else if (charCode <= 0xFFFF) {
-					output[pos++] = charCode>>12 & 0x0F | 0xE0;
-					output[pos++] = charCode>>6  & 0x3F | 0x80;
-					output[pos++] = charCode     & 0x3F | 0x80;
+					output[pos++] = charCode >> 12 & 0x0F | 0xE0;
+					output[pos++] = charCode >> 6 & 0x3F | 0x80;
+					output[pos++] = charCode & 0x3F | 0x80;
 				} else {
-					output[pos++] = charCode>>18 & 0x07 | 0xF0;
-					output[pos++] = charCode>>12 & 0x3F | 0x80;
-					output[pos++] = charCode>>6  & 0x3F | 0x80;
-					output[pos++] = charCode     & 0x3F | 0x80;
+					output[pos++] = charCode >> 18 & 0x07 | 0xF0;
+					output[pos++] = charCode >> 12 & 0x3F | 0x80;
+					output[pos++] = charCode >> 6 & 0x3F | 0x80;
+					output[pos++] = charCode & 0x3F | 0x80;
 				}
 			}
 			return output;
@@ -653,32 +650,28 @@ function onMessageArrived(message) {
 			var utf16;
 			var pos = offset;
 
-			while (pos < offset+length)
-			{
+			while (pos < offset + length) {
 				var byte1 = input[pos++];
 				if (byte1 < 128)
 					utf16 = byte1;
-				else
-				{
-					var byte2 = input[pos++]-128;
+				else {
+					var byte2 = input[pos++] - 128;
 					if (byte2 < 0)
-						throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16),""]));
+						throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), ""]));
 					if (byte1 < 0xE0)             // 2 byte character
-						utf16 = 64*(byte1-0xC0) + byte2;
-					else
-					{
-						var byte3 = input[pos++]-128;
+						utf16 = 64 * (byte1 - 0xC0) + byte2;
+					else {
+						var byte3 = input[pos++] - 128;
 						if (byte3 < 0)
 							throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));
 						if (byte1 < 0xF0)        // 3 byte character
-							utf16 = 4096*(byte1-0xE0) + 64*byte2 + byte3;
-						else
-						{
-							var byte4 = input[pos++]-128;
+							utf16 = 4096 * (byte1 - 0xE0) + 64 * byte2 + byte3;
+						else {
+							var byte4 = input[pos++] - 128;
 							if (byte4 < 0)
 								throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));
 							if (byte1 < 0xF8)        // 4 byte character
-								utf16 = 262144*(byte1-0xF0) + 4096*byte2 + 64*byte3 + byte4;
+								utf16 = 262144 * (byte1 - 0xF0) + 4096 * byte2 + 64 * byte3 + byte4;
 							else                     // longer encodings are not supported
 								throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));
 						}
@@ -700,9 +693,9 @@ function onMessageArrived(message) {
 	 * Repeat keepalive requests, monitor responses.
 	 * @ignore
 	 */
-		var Pinger = function(client, keepAliveInterval) {
+		var Pinger = function (client, keepAliveInterval) {
 			this._client = client;
-			this._keepAliveInterval = keepAliveInterval*1000;
+			this._keepAliveInterval = keepAliveInterval * 1000;
 			this.isReset = false;
 
 			var pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();
@@ -714,10 +707,10 @@ function onMessageArrived(message) {
 			};
 
 			/** @ignore */
-			var doPing = function() {
+			var doPing = function () {
 				if (!this.isReset) {
 					this._client._trace("Pinger.doPing", "Timed out");
-					this._client._disconnected( ERROR.PING_TIMEOUT.code , format(ERROR.PING_TIMEOUT));
+					this._client._disconnected(ERROR.PING_TIMEOUT.code, format(ERROR.PING_TIMEOUT));
 				} else {
 					this.isReset = false;
 					this._client._trace("Pinger.doPing", "send PINGREQ");
@@ -726,14 +719,14 @@ function onMessageArrived(message) {
 				}
 			};
 
-			this.reset = function() {
+			this.reset = function () {
 				this.isReset = true;
 				clearTimeout(this.timeout);
 				if (this._keepAliveInterval > 0)
 					this.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);
 			};
 
-			this.cancel = function() {
+			this.cancel = function () {
 				clearTimeout(this.timeout);
 			};
 		};
@@ -742,7 +735,7 @@ function onMessageArrived(message) {
 	 * Monitor request completion.
 	 * @ignore
 	 */
-		var Timeout = function(client, timeoutSeconds, action, args) {
+		var Timeout = function (client, timeoutSeconds, action, args) {
 			if (!timeoutSeconds)
 				timeoutSeconds = 30;
 
@@ -753,21 +746,21 @@ function onMessageArrived(message) {
 			};
 			this.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);
 
-			this.cancel = function() {
+			this.cancel = function () {
 				clearTimeout(this.timeout);
 			};
 		};
 
-	/**
-	 * Internal implementation of the Websockets MQTT V3.1 client.
-	 *
-	 * @name Paho.ClientImpl @constructor
-	 * @param {String} host the DNS nameof the webSocket host.
-	 * @param {Number} port the port number for that host.
-	 * @param {String} clientId the MQ client identifier.
-	 */
+		/**
+		 * Internal implementation of the Websockets MQTT V3.1 client.
+		 *
+		 * @name Paho.ClientImpl @constructor
+		 * @param {String} host the DNS nameof the webSocket host.
+		 * @param {Number} port the port number for that host.
+		 * @param {String} clientId the MQ client identifier.
+		 */
 		var ClientImpl = function (uri, host, port, path, clientId) {
-		// Check dependencies are satisfied in this browser.
+			// Check dependencies are satisfied in this browser.
 			if (!("WebSocket" in global && global.WebSocket !== null)) {
 				throw new Error(format(ERROR.UNSUPPORTED, ["WebSocket"]));
 			}
@@ -787,7 +780,7 @@ function onMessageArrived(message) {
 			// The conditional inclusion of path in the key is for backward
 			// compatibility to when the path was not configurable and assumed to
 			// be /mqtt
-			this._localKey=host+":"+port+(path!="/mqtt"?":"+path:"")+":"+clientId+":";
+			this._localKey = host + ":" + port + (path != "/mqtt" ? ":" + path : "") + ":" + clientId + ":";
 
 			// Create private instance-only message queue
 			// Internal queue of messages to be sent, in sending order.
@@ -816,7 +809,7 @@ function onMessageArrived(message) {
 
 			// Load the local state, if any, from the saved version, only restore state relevant to this client.
 			for (var key in localStorage)
-				if (   key.indexOf("Sent:"+this._localKey) === 0 || key.indexOf("Received:"+this._localKey) === 0)
+				if (key.indexOf("Sent:" + this._localKey) === 0 || key.indexOf("Received:" + this._localKey) === 0)
 					this.restore(key);
 		};
 
@@ -870,8 +863,8 @@ function onMessageArrived(message) {
 				throw new Error(format(ERROR.INVALID_STATE, ["already connected"]));
 
 			if (this._reconnecting) {
-			// connect() function is called while reconnect is in progress.
-			// Terminate the auto reconnect process to use new connect options.
+				// connect() function is called while reconnect is in progress.
+				// Terminate the auto reconnect process to use new connect options.
 				this._reconnectTimeout.cancel();
 				this._reconnectTimeout = null;
 				this._reconnecting = false;
@@ -895,27 +888,29 @@ function onMessageArrived(message) {
 			if (!this.connected)
 				throw new Error(format(ERROR.INVALID_STATE, ["not connected"]));
 
-            var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);
-            wireMessage.topics = filter.constructor === Array ? filter : [filter];
-            if (subscribeOptions.qos === undefined)
-                subscribeOptions.qos = 0;
-            wireMessage.requestedQos = [];
-            for (var i = 0; i < wireMessage.topics.length; i++)
-                wireMessage.requestedQos[i] = subscribeOptions.qos;
+			var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);
+			wireMessage.topics = filter.constructor === Array ? filter : [filter];
+			if (subscribeOptions.qos === undefined)
+				subscribeOptions.qos = 0;
+			wireMessage.requestedQos = [];
+			for (var i = 0; i < wireMessage.topics.length; i++)
+				wireMessage.requestedQos[i] = subscribeOptions.qos;
 
 			if (subscribeOptions.onSuccess) {
-				wireMessage.onSuccess = function(grantedQos) {subscribeOptions.onSuccess({invocationContext:subscribeOptions.invocationContext,grantedQos:grantedQos});};
+				wireMessage.onSuccess = function (grantedQos) { subscribeOptions.onSuccess({ invocationContext: subscribeOptions.invocationContext, grantedQos: grantedQos }); };
 			}
 
 			if (subscribeOptions.onFailure) {
-				wireMessage.onFailure = function(errorCode) {subscribeOptions.onFailure({invocationContext:subscribeOptions.invocationContext,errorCode:errorCode, errorMessage:format(errorCode)});};
+				wireMessage.onFailure = function (errorCode) { subscribeOptions.onFailure({ invocationContext: subscribeOptions.invocationContext, errorCode: errorCode, errorMessage: format(errorCode) }); };
 			}
 
 			if (subscribeOptions.timeout) {
 				wireMessage.timeOut = new Timeout(this, subscribeOptions.timeout, subscribeOptions.onFailure,
-					[{invocationContext:subscribeOptions.invocationContext,
-						errorCode:ERROR.SUBSCRIBE_TIMEOUT.code,
-						errorMessage:format(ERROR.SUBSCRIBE_TIMEOUT)}]);
+					[{
+						invocationContext: subscribeOptions.invocationContext,
+						errorCode: ERROR.SUBSCRIBE_TIMEOUT.code,
+						errorMessage: format(ERROR.SUBSCRIBE_TIMEOUT)
+					}]);
 			}
 
 			// All subscriptions return a SUBACK.
@@ -924,23 +919,25 @@ function onMessageArrived(message) {
 		};
 
 		/** @ignore */
-		ClientImpl.prototype.unsubscribe = function(filter, unsubscribeOptions) {
+		ClientImpl.prototype.unsubscribe = function (filter, unsubscribeOptions) {
 			this._trace("Client.unsubscribe", filter, unsubscribeOptions);
 
 			if (!this.connected)
 				throw new Error(format(ERROR.INVALID_STATE, ["not connected"]));
 
-            var wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);
-            wireMessage.topics = filter.constructor === Array ? filter : [filter];
+			var wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);
+			wireMessage.topics = filter.constructor === Array ? filter : [filter];
 
 			if (unsubscribeOptions.onSuccess) {
-				wireMessage.callback = function() {unsubscribeOptions.onSuccess({invocationContext:unsubscribeOptions.invocationContext});};
+				wireMessage.callback = function () { unsubscribeOptions.onSuccess({ invocationContext: unsubscribeOptions.invocationContext }); };
 			}
 			if (unsubscribeOptions.timeout) {
 				wireMessage.timeOut = new Timeout(this, unsubscribeOptions.timeout, unsubscribeOptions.onFailure,
-					[{invocationContext:unsubscribeOptions.invocationContext,
-						errorCode:ERROR.UNSUBSCRIBE_TIMEOUT.code,
-						errorMessage:format(ERROR.UNSUBSCRIBE_TIMEOUT)}]);
+					[{
+						invocationContext: unsubscribeOptions.invocationContext,
+						errorCode: ERROR.UNSUBSCRIBE_TIMEOUT.code,
+						errorMessage: format(ERROR.UNSUBSCRIBE_TIMEOUT)
+					}]);
 			}
 
 			// All unsubscribes return a SUBACK.
@@ -955,9 +952,9 @@ function onMessageArrived(message) {
 			wireMessage.payloadMessage = message;
 
 			if (this.connected) {
-			// Mark qos 1 & 2 message as "ACK required"
-			// For qos 0 message, invoke onMessageDelivered callback if there is one.
-			// Then schedule the message.
+				// Mark qos 1 & 2 message as "ACK required"
+				// For qos 0 message, invoke onMessageDelivered callback if there is one.
+				// Then schedule the message.
 				if (message.qos > 0) {
 					this._requires_ack(wireMessage);
 				} else if (this.onMessageDelivered) {
@@ -965,16 +962,16 @@ function onMessageArrived(message) {
 				}
 				this._schedule_message(wireMessage);
 			} else {
-			// Currently disconnected, will not schedule this message
-			// Check if reconnecting is in progress and disconnected publish is enabled.
+				// Currently disconnected, will not schedule this message
+				// Check if reconnecting is in progress and disconnected publish is enabled.
 				if (this._reconnecting && this.disconnectedPublishing) {
-				// Check the limit which include the "required ACK" messages
+					// Check the limit which include the "required ACK" messages
 					var messageCount = Object.keys(this._sentMessages).length + this._buffered_msg_queue.length;
 					if (messageCount > this.disconnectedBufferSize) {
 						throw new Error(format(ERROR.BUFFER_FULL, [this.disconnectedBufferSize]));
 					} else {
 						if (message.qos > 0) {
-						// Mark this message as "ACK required"
+							// Mark this message as "ACK required"
 							this._requires_ack(wireMessage);
 						} else {
 							wireMessage.sequence = ++this._sequence;
@@ -992,8 +989,8 @@ function onMessageArrived(message) {
 			this._trace("Client.disconnect");
 
 			if (this._reconnecting) {
-			// disconnect() function is called while reconnect is in progress.
-			// Terminate the auto reconnect process.
+				// disconnect() function is called while reconnect is in progress.
+				// Terminate the auto reconnect process.
 				this._reconnectTimeout.cancel();
 				this._reconnectTimeout = null;
 				this._reconnecting = false;
@@ -1013,20 +1010,20 @@ function onMessageArrived(message) {
 		};
 
 		ClientImpl.prototype.getTraceLog = function () {
-			if ( this._traceBuffer !== null ) {
+			if (this._traceBuffer !== null) {
 				this._trace("Client.getTraceLog", new Date());
 				this._trace("Client.getTraceLog in flight messages", this._sentMessages.length);
 				for (var key in this._sentMessages)
-					this._trace("_sentMessages ",key, this._sentMessages[key]);
+					this._trace("_sentMessages ", key, this._sentMessages[key]);
 				for (var key in this._receivedMessages)
-					this._trace("_receivedMessages ",key, this._receivedMessages[key]);
+					this._trace("_receivedMessages ", key, this._receivedMessages[key]);
 
 				return this._traceBuffer;
 			}
 		};
 
 		ClientImpl.prototype.startTrace = function () {
-			if ( this._traceBuffer === null ) {
+			if (this._traceBuffer === null) {
 				this._traceBuffer = [];
 			}
 			this._trace("Client.startTrace", new Date(), version);
@@ -1037,7 +1034,7 @@ function onMessageArrived(message) {
 		};
 
 		ClientImpl.prototype._doConnect = function (wsurl) {
-		// When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.
+			// When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.
 			if (this.connectOptions.useSSL) {
 				var uriParts = wsurl.split(":");
 				uriParts[0] = "wss";
@@ -1049,7 +1046,8 @@ function onMessageArrived(message) {
 
 
 			if (this.connectOptions.mqttVersion < 4) {
-				this.socket = new WebSocket(wsurl, ["mqttv3.1"]);
+				this.socket = new WebSocket(wsurl, ["mqttv3.1.1"]);
+				console.log("mqttv3.1.1");
 			} else {
 				this.socket = new WebSocket(wsurl, ["mqtt"]);
 			}
@@ -1065,7 +1063,7 @@ function onMessageArrived(message) {
 				this._connectTimeout.cancel();
 				this._connectTimeout = null;
 			}
-			this._connectTimeout = new Timeout(this, this.connectOptions.timeout, this._disconnected,  [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);
+			this._connectTimeout = new Timeout(this, this.connectOptions.timeout, this._disconnected, [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);
 		};
 
 
@@ -1083,85 +1081,85 @@ function onMessageArrived(message) {
 			}
 		};
 
-		ClientImpl.prototype.store = function(prefix, wireMessage) {
-			var storedMessage = {type:wireMessage.type, messageIdentifier:wireMessage.messageIdentifier, version:1};
-
-			switch(wireMessage.type) {
-			case MESSAGE_TYPE.PUBLISH:
-				if(wireMessage.pubRecReceived)
-					storedMessage.pubRecReceived = true;
-
-				// Convert the payload to a hex string.
-				storedMessage.payloadMessage = {};
-				var hex = "";
-				var messageBytes = wireMessage.payloadMessage.payloadBytes;
-				for (var i=0; i<messageBytes.length; i++) {
-					if (messageBytes[i] <= 0xF)
-						hex = hex+"0"+messageBytes[i].toString(16);
-					else
-						hex = hex+messageBytes[i].toString(16);
-				}
-				storedMessage.payloadMessage.payloadHex = hex;
-
-				storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;
-				storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;
-				if (wireMessage.payloadMessage.duplicate)
-					storedMessage.payloadMessage.duplicate = true;
-				if (wireMessage.payloadMessage.retained)
-					storedMessage.payloadMessage.retained = true;
-
-				// Add a sequence number to sent messages.
-				if ( prefix.indexOf("Sent:") === 0 ) {
-					if ( wireMessage.sequence === undefined )
-						wireMessage.sequence = ++this._sequence;
-					storedMessage.sequence = wireMessage.sequence;
-				}
-				break;
+		ClientImpl.prototype.store = function (prefix, wireMessage) {
+			var storedMessage = { type: wireMessage.type, messageIdentifier: wireMessage.messageIdentifier, version: 1 };
+
+			switch (wireMessage.type) {
+				case MESSAGE_TYPE.PUBLISH:
+					if (wireMessage.pubRecReceived)
+						storedMessage.pubRecReceived = true;
+
+					// Convert the payload to a hex string.
+					storedMessage.payloadMessage = {};
+					var hex = "";
+					var messageBytes = wireMessage.payloadMessage.payloadBytes;
+					for (var i = 0; i < messageBytes.length; i++) {
+						if (messageBytes[i] <= 0xF)
+							hex = hex + "0" + messageBytes[i].toString(16);
+						else
+							hex = hex + messageBytes[i].toString(16);
+					}
+					storedMessage.payloadMessage.payloadHex = hex;
+
+					storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;
+					storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;
+					if (wireMessage.payloadMessage.duplicate)
+						storedMessage.payloadMessage.duplicate = true;
+					if (wireMessage.payloadMessage.retained)
+						storedMessage.payloadMessage.retained = true;
+
+					// Add a sequence number to sent messages.
+					if (prefix.indexOf("Sent:") === 0) {
+						if (wireMessage.sequence === undefined)
+							wireMessage.sequence = ++this._sequence;
+						storedMessage.sequence = wireMessage.sequence;
+					}
+					break;
 
-			default:
-				throw Error(format(ERROR.INVALID_STORED_DATA, [prefix+this._localKey+wireMessage.messageIdentifier, storedMessage]));
+				default:
+					throw Error(format(ERROR.INVALID_STORED_DATA, [prefix + this._localKey + wireMessage.messageIdentifier, storedMessage]));
 			}
-			localStorage.setItem(prefix+this._localKey+wireMessage.messageIdentifier, JSON.stringify(storedMessage));
+			localStorage.setItem(prefix + this._localKey + wireMessage.messageIdentifier, JSON.stringify(storedMessage));
 		};
 
-		ClientImpl.prototype.restore = function(key) {
+		ClientImpl.prototype.restore = function (key) {
 			var value = localStorage.getItem(key);
 			var storedMessage = JSON.parse(value);
 
 			var wireMessage = new WireMessage(storedMessage.type, storedMessage);
 
-			switch(storedMessage.type) {
-			case MESSAGE_TYPE.PUBLISH:
-				// Replace the payload message with a Message object.
-				var hex = storedMessage.payloadMessage.payloadHex;
-				var buffer = new ArrayBuffer((hex.length)/2);
-				var byteStream = new Uint8Array(buffer);
-				var i = 0;
-				while (hex.length >= 2) {
-					var x = parseInt(hex.substring(0, 2), 16);
-					hex = hex.substring(2, hex.length);
-					byteStream[i++] = x;
-				}
-				var payloadMessage = new Message(byteStream);
+			switch (storedMessage.type) {
+				case MESSAGE_TYPE.PUBLISH:
+					// Replace the payload message with a Message object.
+					var hex = storedMessage.payloadMessage.payloadHex;
+					var buffer = new ArrayBuffer((hex.length) / 2);
+					var byteStream = new Uint8Array(buffer);
+					var i = 0;
+					while (hex.length >= 2) {
+						var x = parseInt(hex.substring(0, 2), 16);
+						hex = hex.substring(2, hex.length);
+						byteStream[i++] = x;
+					}
+					var payloadMessage = new Message(byteStream);
 
-				payloadMessage.qos = storedMessage.payloadMessage.qos;
-				payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;
-				if (storedMessage.payloadMessage.duplicate)
-					payloadMessage.duplicate = true;
-				if (storedMessage.payloadMessage.retained)
-					payloadMessage.retained = true;
-				wireMessage.payloadMessage = payloadMessage;
+					payloadMessage.qos = storedMessage.payloadMessage.qos;
+					payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;
+					if (storedMessage.payloadMessage.duplicate)
+						payloadMessage.duplicate = true;
+					if (storedMessage.payloadMessage.retained)
+						payloadMessage.retained = true;
+					wireMessage.payloadMessage = payloadMessage;
 
-				break;
+					break;
 
-			default:
-				throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));
+				default:
+					throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));
 			}
 
-			if (key.indexOf("Sent:"+this._localKey) === 0) {
+			if (key.indexOf("Sent:" + this._localKey) === 0) {
 				wireMessage.payloadMessage.duplicate = true;
 				this._sentMessages[wireMessage.messageIdentifier] = wireMessage;
-			} else if (key.indexOf("Received:"+this._localKey) === 0) {
+			} else if (key.indexOf("Received:" + this._localKey) === 0) {
 				this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;
 			}
 		};
@@ -1188,9 +1186,9 @@ function onMessageArrived(message) {
 		ClientImpl.prototype._requires_ack = function (wireMessage) {
 			var messageCount = Object.keys(this._sentMessages).length;
 			if (messageCount > this.maxMessageIdentifier)
-				throw Error ("Too many messages:"+messageCount);
+				throw Error("Too many messages:" + messageCount);
 
-			while(this._sentMessages[this._message_identifier] !== undefined) {
+			while (this._sentMessages[this._message_identifier] !== undefined) {
 				this._message_identifier++;
 			}
 			wireMessage.messageIdentifier = this._message_identifier;
@@ -1208,7 +1206,7 @@ function onMessageArrived(message) {
 	 * @ignore
 	 */
 		ClientImpl.prototype._on_socket_open = function () {
-		// Create the CONNECT message object.
+			// Create the CONNECT message object.
 			var wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);
 			wireMessage.clientId = this.clientId;
 			this._socket_send(wireMessage);
@@ -1221,25 +1219,25 @@ function onMessageArrived(message) {
 		ClientImpl.prototype._on_socket_message = function (event) {
 			this._trace("Client._on_socket_message", event.data);
 			var messages = this._deframeMessages(event.data);
-			for (var i = 0; i < messages.length; i+=1) {
+			for (var i = 0; i < messages.length; i += 1) {
 				this._handleMessage(messages[i]);
 			}
 		};
 
-		ClientImpl.prototype._deframeMessages = function(data) {
+		ClientImpl.prototype._deframeMessages = function (data) {
 			var byteArray = new Uint8Array(data);
 			var messages = [];
 			if (this.receiveBuffer) {
-				var newData = new Uint8Array(this.receiveBuffer.length+byteArray.length);
+				var newData = new Uint8Array(this.receiveBuffer.length + byteArray.length);
 				newData.set(this.receiveBuffer);
-				newData.set(byteArray,this.receiveBuffer.length);
+				newData.set(byteArray, this.receiveBuffer.length);
 				byteArray = newData;
 				delete this.receiveBuffer;
 			}
 			try {
 				var offset = 0;
-				while(offset < byteArray.length) {
-					var result = decodeMessage(byteArray,offset);
+				while (offset < byteArray.length) {
+					var result = decodeMessage(byteArray, offset);
 					var wireMessage = result[0];
 					offset = result[1];
 					if (wireMessage !== null) {
@@ -1253,196 +1251,196 @@ function onMessageArrived(message) {
 				}
 			} catch (error) {
 				var errorStack = ((error.hasOwnProperty("stack") == "undefined") ? error.stack.toString() : "No Error Stack Available");
-				this._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message,errorStack]));
+				this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));
 				return;
 			}
 			return messages;
 		};
 
-		ClientImpl.prototype._handleMessage = function(wireMessage) {
+		ClientImpl.prototype._handleMessage = function (wireMessage) {
 
 			this._trace("Client._handleMessage", wireMessage);
 
 			try {
-				switch(wireMessage.type) {
-				case MESSAGE_TYPE.CONNACK:
-					this._connectTimeout.cancel();
-					if (this._reconnectTimeout)
-						this._reconnectTimeout.cancel();
-
-					// If we have started using clean session then clear up the local state.
-					if (this.connectOptions.cleanSession) {
-						for (var key in this._sentMessages) {
-							var sentMessage = this._sentMessages[key];
-							localStorage.removeItem("Sent:"+this._localKey+sentMessage.messageIdentifier);
-						}
-						this._sentMessages = {};
+				switch (wireMessage.type) {
+					case MESSAGE_TYPE.CONNACK:
+						this._connectTimeout.cancel();
+						if (this._reconnectTimeout)
+							this._reconnectTimeout.cancel();
+
+						// If we have started using clean session then clear up the local state.
+						if (this.connectOptions.cleanSession) {
+							for (var key in this._sentMessages) {
+								var sentMessage = this._sentMessages[key];
+								localStorage.removeItem("Sent:" + this._localKey + sentMessage.messageIdentifier);
+							}
+							this._sentMessages = {};
 
-						for (var key in this._receivedMessages) {
-							var receivedMessage = this._receivedMessages[key];
-							localStorage.removeItem("Received:"+this._localKey+receivedMessage.messageIdentifier);
+							for (var key in this._receivedMessages) {
+								var receivedMessage = this._receivedMessages[key];
+								localStorage.removeItem("Received:" + this._localKey + receivedMessage.messageIdentifier);
+							}
+							this._receivedMessages = {};
 						}
-						this._receivedMessages = {};
-					}
-					// Client connected and ready for business.
-					if (wireMessage.returnCode === 0) {
+						// Client connected and ready for business.
+						if (wireMessage.returnCode === 0) {
 
-						this.connected = true;
-						// Jump to the end of the list of uris and stop looking for a good host.
+							this.connected = true;
+							// Jump to the end of the list of uris and stop looking for a good host.
 
-						if (this.connectOptions.uris)
-							this.hostIndex = this.connectOptions.uris.length;
+							if (this.connectOptions.uris)
+								this.hostIndex = this.connectOptions.uris.length;
 
-					} else {
-						this._disconnected(ERROR.CONNACK_RETURNCODE.code , format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));
-						break;
-					}
+						} else {
+							this._disconnected(ERROR.CONNACK_RETURNCODE.code, format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));
+							break;
+						}
 
-					// Resend messages.
-					var sequencedMessages = [];
-					for (var msgId in this._sentMessages) {
-						if (this._sentMessages.hasOwnProperty(msgId))
-							sequencedMessages.push(this._sentMessages[msgId]);
-					}
+						// Resend messages.
+						var sequencedMessages = [];
+						for (var msgId in this._sentMessages) {
+							if (this._sentMessages.hasOwnProperty(msgId))
+								sequencedMessages.push(this._sentMessages[msgId]);
+						}
 
-					// Also schedule qos 0 buffered messages if any
-					if (this._buffered_msg_queue.length > 0) {
-						var msg = null;
-						while ((msg = this._buffered_msg_queue.pop())) {
-							sequencedMessages.push(msg);
-							if (this.onMessageDelivered)
-								this._notify_msg_sent[msg] = this.onMessageDelivered(msg.payloadMessage);
+						// Also schedule qos 0 buffered messages if any
+						if (this._buffered_msg_queue.length > 0) {
+							var msg = null;
+							while ((msg = this._buffered_msg_queue.pop())) {
+								sequencedMessages.push(msg);
+								if (this.onMessageDelivered)
+									this._notify_msg_sent[msg] = this.onMessageDelivered(msg.payloadMessage);
+							}
 						}
-					}
 
-					// Sort sentMessages into the original sent order.
-					var sequencedMessages = sequencedMessages.sort(function(a,b) {return a.sequence - b.sequence;} );
-					for (var i=0, len=sequencedMessages.length; i<len; i++) {
-						var sentMessage = sequencedMessages[i];
-						if (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {
-							var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:sentMessage.messageIdentifier});
-							this._schedule_message(pubRelMessage);
-						} else {
-							this._schedule_message(sentMessage);
+						// Sort sentMessages into the original sent order.
+						var sequencedMessages = sequencedMessages.sort(function (a, b) { return a.sequence - b.sequence; });
+						for (var i = 0, len = sequencedMessages.length; i < len; i++) {
+							var sentMessage = sequencedMessages[i];
+							if (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {
+								var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, { messageIdentifier: sentMessage.messageIdentifier });
+								this._schedule_message(pubRelMessage);
+							} else {
+								this._schedule_message(sentMessage);
+							}
 						}
-					}
 
-					// Execute the connectOptions.onSuccess callback if there is one.
-					// Will also now return if this connection was the result of an automatic
-					// reconnect and which URI was successfully connected to.
-					if (this.connectOptions.onSuccess) {
-						this.connectOptions.onSuccess({invocationContext:this.connectOptions.invocationContext});
-					}
+						// Execute the connectOptions.onSuccess callback if there is one.
+						// Will also now return if this connection was the result of an automatic
+						// reconnect and which URI was successfully connected to.
+						if (this.connectOptions.onSuccess) {
+							this.connectOptions.onSuccess({ invocationContext: this.connectOptions.invocationContext });
+						}
 
-					var reconnected = false;
-					if (this._reconnecting) {
-						reconnected = true;
-						this._reconnectInterval = 1;
-						this._reconnecting = false;
-					}
+						var reconnected = false;
+						if (this._reconnecting) {
+							reconnected = true;
+							this._reconnectInterval = 1;
+							this._reconnecting = false;
+						}
 
-					// Execute the onConnected callback if there is one.
-					this._connected(reconnected, this._wsuri);
+						// Execute the onConnected callback if there is one.
+						this._connected(reconnected, this._wsuri);
 
-					// Process all queued messages now that the connection is established.
-					this._process_queue();
-					break;
+						// Process all queued messages now that the connection is established.
+						this._process_queue();
+						break;
 
-				case MESSAGE_TYPE.PUBLISH:
-					this._receivePublish(wireMessage);
-					break;
+					case MESSAGE_TYPE.PUBLISH:
+						this._receivePublish(wireMessage);
+						break;
 
-				case MESSAGE_TYPE.PUBACK:
-					var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
-					// If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.
-					if (sentMessage) {
-						delete this._sentMessages[wireMessage.messageIdentifier];
-						localStorage.removeItem("Sent:"+this._localKey+wireMessage.messageIdentifier);
-						if (this.onMessageDelivered)
-							this.onMessageDelivered(sentMessage.payloadMessage);
-					}
-					break;
+					case MESSAGE_TYPE.PUBACK:
+						var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
+						// If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.
+						if (sentMessage) {
+							delete this._sentMessages[wireMessage.messageIdentifier];
+							localStorage.removeItem("Sent:" + this._localKey + wireMessage.messageIdentifier);
+							if (this.onMessageDelivered)
+								this.onMessageDelivered(sentMessage.payloadMessage);
+						}
+						break;
 
-				case MESSAGE_TYPE.PUBREC:
-					var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
-					// If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.
-					if (sentMessage) {
-						sentMessage.pubRecReceived = true;
-						var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:wireMessage.messageIdentifier});
-						this.store("Sent:", sentMessage);
-						this._schedule_message(pubRelMessage);
-					}
-					break;
+					case MESSAGE_TYPE.PUBREC:
+						var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
+						// If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.
+						if (sentMessage) {
+							sentMessage.pubRecReceived = true;
+							var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, { messageIdentifier: wireMessage.messageIdentifier });
+							this.store("Sent:", sentMessage);
+							this._schedule_message(pubRelMessage);
+						}
+						break;
 
-				case MESSAGE_TYPE.PUBREL:
-					var receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];
-					localStorage.removeItem("Received:"+this._localKey+wireMessage.messageIdentifier);
-					// If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.
-					if (receivedMessage) {
-						this._receiveMessage(receivedMessage);
-						delete this._receivedMessages[wireMessage.messageIdentifier];
-					}
-					// Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.
-					var pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, {messageIdentifier:wireMessage.messageIdentifier});
-					this._schedule_message(pubCompMessage);
+					case MESSAGE_TYPE.PUBREL:
+						var receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];
+						localStorage.removeItem("Received:" + this._localKey + wireMessage.messageIdentifier);
+						// If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.
+						if (receivedMessage) {
+							this._receiveMessage(receivedMessage);
+							delete this._receivedMessages[wireMessage.messageIdentifier];
+						}
+						// Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.
+						var pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, { messageIdentifier: wireMessage.messageIdentifier });
+						this._schedule_message(pubCompMessage);
 
 
-					break;
+						break;
 
-				case MESSAGE_TYPE.PUBCOMP:
-					var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
-					delete this._sentMessages[wireMessage.messageIdentifier];
-					localStorage.removeItem("Sent:"+this._localKey+wireMessage.messageIdentifier);
-					if (this.onMessageDelivered)
-						this.onMessageDelivered(sentMessage.payloadMessage);
-					break;
+					case MESSAGE_TYPE.PUBCOMP:
+						var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
+						delete this._sentMessages[wireMessage.messageIdentifier];
+						localStorage.removeItem("Sent:" + this._localKey + wireMessage.messageIdentifier);
+						if (this.onMessageDelivered)
+							this.onMessageDelivered(sentMessage.payloadMessage);
+						break;
 
-				case MESSAGE_TYPE.SUBACK:
-					var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
-					if (sentMessage) {
-						if(sentMessage.timeOut)
-							sentMessage.timeOut.cancel();
-						// This will need to be fixed when we add multiple topic support
-						if (wireMessage.returnCode[0] === 0x80) {
-							if (sentMessage.onFailure) {
-								sentMessage.onFailure(wireMessage.returnCode);
+					case MESSAGE_TYPE.SUBACK:
+						var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
+						if (sentMessage) {
+							if (sentMessage.timeOut)
+								sentMessage.timeOut.cancel();
+							// This will need to be fixed when we add multiple topic support
+							if (wireMessage.returnCode[0] === 0x80) {
+								if (sentMessage.onFailure) {
+									sentMessage.onFailure(wireMessage.returnCode);
+								}
+							} else if (sentMessage.onSuccess) {
+								sentMessage.onSuccess(wireMessage.returnCode);
 							}
-						} else if (sentMessage.onSuccess) {
-							sentMessage.onSuccess(wireMessage.returnCode);
+							delete this._sentMessages[wireMessage.messageIdentifier];
 						}
-						delete this._sentMessages[wireMessage.messageIdentifier];
-					}
-					break;
+						break;
 
-				case MESSAGE_TYPE.UNSUBACK:
-					var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
-					if (sentMessage) {
-						if (sentMessage.timeOut)
-							sentMessage.timeOut.cancel();
-						if (sentMessage.callback) {
-							sentMessage.callback();
+					case MESSAGE_TYPE.UNSUBACK:
+						var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
+						if (sentMessage) {
+							if (sentMessage.timeOut)
+								sentMessage.timeOut.cancel();
+							if (sentMessage.callback) {
+								sentMessage.callback();
+							}
+							delete this._sentMessages[wireMessage.messageIdentifier];
 						}
-						delete this._sentMessages[wireMessage.messageIdentifier];
-					}
 
-					break;
+						break;
 
-				case MESSAGE_TYPE.PINGRESP:
-				/* The sendPinger or receivePinger may have sent a ping, the receivePinger has already been reset. */
-					this.sendPinger.reset();
-					break;
+					case MESSAGE_TYPE.PINGRESP:
+						/* The sendPinger or receivePinger may have sent a ping, the receivePinger has already been reset. */
+						this.sendPinger.reset();
+						break;
 
-				case MESSAGE_TYPE.DISCONNECT:
-				// Clients do not expect to receive disconnect packets.
-					this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));
-					break;
+					case MESSAGE_TYPE.DISCONNECT:
+						// Clients do not expect to receive disconnect packets.
+						this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));
+						break;
 
-				default:
-					this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));
+					default:
+						this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));
 				}
 			} catch (error) {
 				var errorStack = ((error.hasOwnProperty("stack") == "undefined") ? error.stack.toString() : "No Error Stack Available");
-				this._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message,errorStack]));
+				this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));
 				return;
 			}
 		};
@@ -1450,14 +1448,14 @@ function onMessageArrived(message) {
 		/** @ignore */
 		ClientImpl.prototype._on_socket_error = function (error) {
 			if (!this._reconnecting) {
-				this._disconnected(ERROR.SOCKET_ERROR.code , format(ERROR.SOCKET_ERROR, [error.data]));
+				this._disconnected(ERROR.SOCKET_ERROR.code, format(ERROR.SOCKET_ERROR, [error.data]));
 			}
 		};
 
 		/** @ignore */
 		ClientImpl.prototype._on_socket_close = function () {
 			if (!this._reconnecting) {
-				this._disconnected(ERROR.SOCKET_CLOSE.code , format(ERROR.SOCKET_CLOSE));
+				this._disconnected(ERROR.SOCKET_CLOSE.code, format(ERROR.SOCKET_CLOSE));
 			}
 		};
 
@@ -1477,28 +1475,28 @@ function onMessageArrived(message) {
 
 		/** @ignore */
 		ClientImpl.prototype._receivePublish = function (wireMessage) {
-			switch(wireMessage.payloadMessage.qos) {
-			case "undefined":
-			case 0:
-				this._receiveMessage(wireMessage);
-				break;
-
-			case 1:
-				var pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, {messageIdentifier:wireMessage.messageIdentifier});
-				this._schedule_message(pubAckMessage);
-				this._receiveMessage(wireMessage);
-				break;
-
-			case 2:
-				this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;
-				this.store("Received:", wireMessage);
-				var pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, {messageIdentifier:wireMessage.messageIdentifier});
-				this._schedule_message(pubRecMessage);
+			switch (wireMessage.payloadMessage.qos) {
+				case "undefined":
+				case 0:
+					this._receiveMessage(wireMessage);
+					break;
+
+				case 1:
+					var pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, { messageIdentifier: wireMessage.messageIdentifier });
+					this._schedule_message(pubAckMessage);
+					this._receiveMessage(wireMessage);
+					break;
+
+				case 2:
+					this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;
+					this.store("Received:", wireMessage);
+					var pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, { messageIdentifier: wireMessage.messageIdentifier });
+					this._schedule_message(pubRecMessage);
 
-				break;
+					break;
 
-			default:
-				throw Error("Invaild qos=" + wireMessage.payloadMessage.qos);
+				default:
+					throw Error("Invaild qos=" + wireMessage.payloadMessage.qos);
 			}
 		};
 
@@ -1515,15 +1513,15 @@ function onMessageArrived(message) {
 	 * @param {uri} [string] fully qualified WebSocket URI of the server.
 	 */
 		ClientImpl.prototype._connected = function (reconnect, uri) {
-		// Execute the onConnected callback if there is one.
+			// Execute the onConnected callback if there is one.
 			if (this.onConnected)
 				this.onConnected(reconnect, uri);
 		};
 
 		/**
 	 * Attempts to reconnect the client to the server.
-   * For each reconnect attempt, will double the reconnect interval
-   * up to 128 seconds.
+	 * For each reconnect attempt, will double the reconnect interval
+	 * up to 128 seconds.
 	 */
 		ClientImpl.prototype._reconnect = function () {
 			this._trace("Client._reconnect");
@@ -1571,7 +1569,7 @@ function onMessageArrived(message) {
 			this._notify_msg_sent = {};
 
 			if (this.socket) {
-			// Cancel all socket callbacks so that they cannot be driven again by this socket.
+				// Cancel all socket callbacks so that they cannot be driven again by this socket.
 				this.socket.onopen = null;
 				this.socket.onmessage = null;
 				this.socket.onerror = null;
@@ -1581,8 +1579,8 @@ function onMessageArrived(message) {
 				delete this.socket;
 			}
 
-			if (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length-1) {
-			// Try the next host.
+			if (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) {
+				// Try the next host.
 				this.hostIndex++;
 				this._doConnect(this.connectOptions.uris[this.hostIndex]);
 			} else {
@@ -1597,16 +1595,16 @@ function onMessageArrived(message) {
 					this.connected = false;
 					// Execute the connectionLostCallback if there is one, and we were connected.
 					if (this.onConnectionLost) {
-						this.onConnectionLost({errorCode:errorCode, errorMessage:errorText, reconnect:this.connectOptions.reconnect, uri:this._wsuri});
+						this.onConnectionLost({ errorCode: errorCode, errorMessage: errorText, reconnect: this.connectOptions.reconnect, uri: this._wsuri });
 					}
 					if (errorCode !== ERROR.OK.code && this.connectOptions.reconnect) {
-					// Start automatic reconnect process for the very first time since last successful connect.
+						// Start automatic reconnect process for the very first time since last successful connect.
 						this._reconnectInterval = 1;
 						this._reconnect();
 						return;
 					}
 				} else {
-				// Otherwise we never had a connection, so indicate that the connect has failed.
+					// Otherwise we never had a connection, so indicate that the connect has failed.
 					if (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {
 						this._trace("Failed to connect V4, dropping back to V3");
 						this.connectOptions.mqttVersion = 3;
@@ -1616,8 +1614,8 @@ function onMessageArrived(message) {
 						} else {
 							this._doConnect(this.uri);
 						}
-					} else if(this.connectOptions.onFailure) {
-						this.connectOptions.onFailure({invocationContext:this.connectOptions.invocationContext, errorCode:errorCode, errorMessage:errorText});
+					} else if (this.connectOptions.onFailure) {
+						this.connectOptions.onFailure({ invocationContext: this.connectOptions.invocationContext, errorCode: errorCode, errorMessage: errorText });
 					}
 				}
 			}
@@ -1625,27 +1623,26 @@ function onMessageArrived(message) {
 
 		/** @ignore */
 		ClientImpl.prototype._trace = function () {
-		// Pass trace message back to client's callback function
+			// Pass trace message back to client's callback function
 			if (this.traceFunction) {
 				var args = Array.prototype.slice.call(arguments);
-				for (var i in args)
-				{
+				for (var i in args) {
 					if (typeof args[i] !== "undefined")
 						args.splice(i, 1, JSON.stringify(args[i]));
 				}
 				var record = args.join("");
-				this.traceFunction ({severity: "Debug", message: record	});
+				this.traceFunction({ severity: "Debug", message: record });
 			}
 
 			//buffer style trace
-			if ( this._traceBuffer !== null ) {
+			if (this._traceBuffer !== null) {
 				for (var i = 0, max = arguments.length; i < max; i++) {
-					if ( this._traceBuffer.length == this._MAX_TRACE_ENTRIES ) {
+					if (this._traceBuffer.length == this._MAX_TRACE_ENTRIES) {
 						this._traceBuffer.shift();
 					}
 					if (i === 0) this._traceBuffer.push(arguments[i]);
-					else if (typeof arguments[i] === "undefined" ) this._traceBuffer.push(arguments[i]);
-					else this._traceBuffer.push("  "+JSON.stringify(arguments[i]));
+					else if (typeof arguments[i] === "undefined") this._traceBuffer.push(arguments[i]);
+					else this._traceBuffer.push("  " + JSON.stringify(arguments[i]));
 				}
 			}
 		};
@@ -1745,17 +1742,17 @@ function onMessageArrived(message) {
 				throw new Error(format(ERROR.INVALID_TYPE, [typeof host, "host"]));
 
 			if (arguments.length == 2) {
-			// host: must be full ws:// uri
-			// port: clientId
+				// host: must be full ws:// uri
+				// port: clientId
 				clientId = port;
 				uri = host;
 				var match = uri.match(/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/);
 				if (match) {
-					host = match[4]||match[2];
+					host = match[4] || match[2];
 					port = parseInt(match[7]);
 					path = match[8];
 				} else {
-					throw new Error(format(ERROR.INVALID_ARGUMENT,[host,"host"]));
+					throw new Error(format(ERROR.INVALID_ARGUMENT, [host, "host"]));
 				}
 			} else {
 				if (arguments.length == 3) {
@@ -1767,14 +1764,14 @@ function onMessageArrived(message) {
 				if (typeof path !== "string")
 					throw new Error(format(ERROR.INVALID_TYPE, [typeof path, "path"]));
 
-				var ipv6AddSBracket = (host.indexOf(":") !== -1 && host.slice(0,1) !== "[" && host.slice(-1) !== "]");
-				uri = "ws://"+(ipv6AddSBracket?"["+host+"]":host)+":"+port+path;
+				var ipv6AddSBracket = (host.indexOf(":") !== -1 && host.slice(0, 1) !== "[" && host.slice(-1) !== "]");
+				uri = "ws://" + (ipv6AddSBracket ? "[" + host + "]" : host) + ":" + port + path;
 			}
 
 			var clientIdLength = 0;
-			for (var i = 0; i<clientId.length; i++) {
+			for (var i = 0; i < clientId.length; i++) {
 				var charCode = clientId.charCodeAt(i);
-				if (0xD800 <= charCode && charCode <= 0xDBFF)  {
+				if (0xD800 <= charCode && charCode <= 0xDBFF) {
 					i++; // Surrogate pair.
 				}
 				clientIdLength++;
@@ -1785,81 +1782,81 @@ function onMessageArrived(message) {
 			var client = new ClientImpl(uri, host, port, path, clientId);
 
 			//Public Properties
-			Object.defineProperties(this,{
-				"host":{
-					get: function() { return host; },
-					set: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
+			Object.defineProperties(this, {
+				"host": {
+					get: function () { return host; },
+					set: function () { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
 				},
-				"port":{
-					get: function() { return port; },
-					set: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
+				"port": {
+					get: function () { return port; },
+					set: function () { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
 				},
-				"path":{
-					get: function() { return path; },
-					set: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
+				"path": {
+					get: function () { return path; },
+					set: function () { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
 				},
-				"uri":{
-					get: function() { return uri; },
-					set: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
+				"uri": {
+					get: function () { return uri; },
+					set: function () { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
 				},
-				"clientId":{
-					get: function() { return client.clientId; },
-					set: function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
+				"clientId": {
+					get: function () { return client.clientId; },
+					set: function () { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); }
 				},
-				"onConnected":{
-					get: function() { return client.onConnected; },
-					set: function(newOnConnected) {
+				"onConnected": {
+					get: function () { return client.onConnected; },
+					set: function (newOnConnected) {
 						if (typeof newOnConnected === "function")
 							client.onConnected = newOnConnected;
 						else
 							throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnected, "onConnected"]));
 					}
 				},
-				"disconnectedPublishing":{
-					get: function() { return client.disconnectedPublishing; },
-					set: function(newDisconnectedPublishing) {
+				"disconnectedPublishing": {
+					get: function () { return client.disconnectedPublishing; },
+					set: function (newDisconnectedPublishing) {
 						client.disconnectedPublishing = newDisconnectedPublishing;
 					}
 				},
-				"disconnectedBufferSize":{
-					get: function() { return client.disconnectedBufferSize; },
-					set: function(newDisconnectedBufferSize) {
+				"disconnectedBufferSize": {
+					get: function () { return client.disconnectedBufferSize; },
+					set: function (newDisconnectedBufferSize) {
 						client.disconnectedBufferSize = newDisconnectedBufferSize;
 					}
 				},
-				"onConnectionLost":{
-					get: function() { return client.onConnectionLost; },
-					set: function(newOnConnectionLost) {
+				"onConnectionLost": {
+					get: function () { return client.onConnectionLost; },
+					set: function (newOnConnectionLost) {
 						if (typeof newOnConnectionLost === "function")
 							client.onConnectionLost = newOnConnectionLost;
 						else
 							throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, "onConnectionLost"]));
 					}
 				},
-				"onMessageDelivered":{
-					get: function() { return client.onMessageDelivered; },
-					set: function(newOnMessageDelivered) {
+				"onMessageDelivered": {
+					get: function () { return client.onMessageDelivered; },
+					set: function (newOnMessageDelivered) {
 						if (typeof newOnMessageDelivered === "function")
 							client.onMessageDelivered = newOnMessageDelivered;
 						else
 							throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, "onMessageDelivered"]));
 					}
 				},
-				"onMessageArrived":{
-					get: function() { return client.onMessageArrived; },
-					set: function(newOnMessageArrived) {
+				"onMessageArrived": {
+					get: function () { return client.onMessageArrived; },
+					set: function (newOnMessageArrived) {
 						if (typeof newOnMessageArrived === "function")
 							client.onMessageArrived = newOnMessageArrived;
 						else
 							throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, "onMessageArrived"]));
 					}
 				},
-				"trace":{
-					get: function() { return client.traceFunction; },
-					set: function(trace) {
-						if(typeof trace === "function"){
+				"trace": {
+					get: function () { return client.traceFunction; },
+					set: function (trace) {
+						if (typeof trace === "function") {
 							client.traceFunction = trace;
-						}else{
+						} else {
 							throw new Error(format(ERROR.INVALID_TYPE, [typeof trace, "onTrace"]));
 						}
 					}
@@ -1929,23 +1926,25 @@ function onMessageArrived(message) {
 		 * or disconnected before calling connect for a second or subsequent time.
 		 */
 			this.connect = function (connectOptions) {
-				connectOptions = connectOptions || {} ;
-				validate(connectOptions,  {timeout:"number",
-					userName:"string",
-					password:"string",
-					willMessage:"object",
-					keepAliveInterval:"number",
-					cleanSession:"boolean",
-					useSSL:"boolean",
-					invocationContext:"object",
-					onSuccess:"function",
-					onFailure:"function",
-					hosts:"object",
-					ports:"object",
-					reconnect:"boolean",
-					mqttVersion:"number",
-					mqttVersionExplicit:"boolean",
-					uris: "object"});
+				connectOptions = connectOptions || {};
+				validate(connectOptions, {
+					timeout: "number",
+					userName: "string",
+					password: "string",
+					willMessage: "object",
+					keepAliveInterval: "number",
+					cleanSession: "boolean",
+					useSSL: "boolean",
+					invocationContext: "object",
+					onSuccess: "function",
+					onFailure: "function",
+					hosts: "object",
+					ports: "object",
+					reconnect: "boolean",
+					mqttVersion: "number",
+					mqttVersionExplicit: "boolean",
+					uris: "object"
+				});
 
 				// If no keep alive interval is set, assume 60 seconds.
 				if (connectOptions.keepAliveInterval === undefined)
@@ -1980,44 +1979,44 @@ function onMessageArrived(message) {
 					connectOptions.cleanSession = true;
 				if (connectOptions.hosts) {
 
-					if (!(connectOptions.hosts instanceof Array) )
+					if (!(connectOptions.hosts instanceof Array))
 						throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, "connectOptions.hosts"]));
-					if (connectOptions.hosts.length <1 )
+					if (connectOptions.hosts.length < 1)
 						throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, "connectOptions.hosts"]));
 
 					var usingURIs = false;
-					for (var i = 0; i<connectOptions.hosts.length; i++) {
+					for (var i = 0; i < connectOptions.hosts.length; i++) {
 						if (typeof connectOptions.hosts[i] !== "string")
-							throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], "connectOptions.hosts["+i+"]"]));
+							throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], "connectOptions.hosts[" + i + "]"]));
 						if (/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/.test(connectOptions.hosts[i])) {
 							if (i === 0) {
 								usingURIs = true;
 							} else if (!usingURIs) {
-								throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], "connectOptions.hosts["+i+"]"]));
+								throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], "connectOptions.hosts[" + i + "]"]));
 							}
 						} else if (usingURIs) {
-							throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], "connectOptions.hosts["+i+"]"]));
+							throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], "connectOptions.hosts[" + i + "]"]));
 						}
 					}
 
 					if (!usingURIs) {
 						if (!connectOptions.ports)
 							throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
-						if (!(connectOptions.ports instanceof Array) )
+						if (!(connectOptions.ports instanceof Array))
 							throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
 						if (connectOptions.hosts.length !== connectOptions.ports.length)
 							throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
 
 						connectOptions.uris = [];
 
-						for (var i = 0; i<connectOptions.hosts.length; i++) {
+						for (var i = 0; i < connectOptions.hosts.length; i++) {
 							if (typeof connectOptions.ports[i] !== "number" || connectOptions.ports[i] < 0)
-								throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], "connectOptions.ports["+i+"]"]));
+								throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], "connectOptions.ports[" + i + "]"]));
 							var host = connectOptions.hosts[i];
 							var port = connectOptions.ports[i];
 
 							var ipv6 = (host.indexOf(":") !== -1);
-							uri = "ws://"+(ipv6?"["+host+"]":host)+":"+port+path;
+							uri = "ws://" + (ipv6 ? "[" + host + "]" : host) + ":" + port + path;
 							connectOptions.uris.push(uri);
 						}
 					} else {
@@ -2062,57 +2061,59 @@ function onMessageArrived(message) {
 		 */
 			this.subscribe = function (filter, subscribeOptions) {
 				if (typeof filter !== "string" && filter.constructor !== Array)
-					throw new Error("Invalid argument:"+filter);
-				subscribeOptions = subscribeOptions || {} ;
-				validate(subscribeOptions,  {qos:"number",
-					invocationContext:"object",
-					onSuccess:"function",
-					onFailure:"function",
-					timeout:"number"
+					throw new Error("Invalid argument:" + filter);
+				subscribeOptions = subscribeOptions || {};
+				validate(subscribeOptions, {
+					qos: "number",
+					invocationContext: "object",
+					onSuccess: "function",
+					onFailure: "function",
+					timeout: "number"
 				});
 				if (subscribeOptions.timeout && !subscribeOptions.onFailure)
 					throw new Error("subscribeOptions.timeout specified with no onFailure callback.");
-				if (typeof subscribeOptions.qos !== "undefined" && !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2 ))
+				if (typeof subscribeOptions.qos !== "undefined" && !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2))
 					throw new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, "subscribeOptions.qos"]));
 				client.subscribe(filter, subscribeOptions);
 			};
 
-		/**
-		 * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.
-		 *
-		 * @name Paho.Client#unsubscribe
-		 * @function
-		 * @param {string} filter - describing the destinations to receive messages from.
-		 * @param {object} unsubscribeOptions - used to control the subscription
-		 * @param {object} unsubscribeOptions.invocationContext - passed to the onSuccess callback
-											  or onFailure callback.
-		 * @param {function} unsubscribeOptions.onSuccess - called when the unsubscribe acknowledgement has been received from the server.
-		 *                                    A single response object parameter is passed to the
-		 *                                    onSuccess callback containing the following fields:
-		 *                                    <ol>
-		 *                                    <li>invocationContext - if set in the unsubscribeOptions.
-		 *                                    </ol>
-		 * @param {function} unsubscribeOptions.onFailure called when the unsubscribe request has failed or timed out.
-		 *                                    A single response object parameter is passed to the onFailure callback containing the following fields:
-		 *                                    <ol>
-		 *                                    <li>invocationContext - if set in the unsubscribeOptions.
-		 *                                    <li>errorCode - a number indicating the nature of the error.
-		 *                                    <li>errorMessage - text describing the error.
-		 *                                    </ol>
-		 * @param {number} unsubscribeOptions.timeout - which, if present, determines the number of seconds
-		 *                                    after which the onFailure callback is called. The presence of
-		 *                                    a timeout does not prevent the onSuccess callback from being
-		 *                                    called when the unsubscribe completes
-		 * @throws {InvalidState} if the client is not in connected state.
-		 */
+			/**
+			 * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.
+			 *
+			 * @name Paho.Client#unsubscribe
+			 * @function
+			 * @param {string} filter - describing the destinations to receive messages from.
+			 * @param {object} unsubscribeOptions - used to control the subscription
+			 * @param {object} unsubscribeOptions.invocationContext - passed to the onSuccess callback
+													or onFailure callback.
+			 * @param {function} unsubscribeOptions.onSuccess - called when the unsubscribe acknowledgement has been received from the server.
+			 *                                    A single response object parameter is passed to the
+			 *                                    onSuccess callback containing the following fields:
+			 *                                    <ol>
+			 *                                    <li>invocationContext - if set in the unsubscribeOptions.
+			 *                                    </ol>
+			 * @param {function} unsubscribeOptions.onFailure called when the unsubscribe request has failed or timed out.
+			 *                                    A single response object parameter is passed to the onFailure callback containing the following fields:
+			 *                                    <ol>
+			 *                                    <li>invocationContext - if set in the unsubscribeOptions.
+			 *                                    <li>errorCode - a number indicating the nature of the error.
+			 *                                    <li>errorMessage - text describing the error.
+			 *                                    </ol>
+			 * @param {number} unsubscribeOptions.timeout - which, if present, determines the number of seconds
+			 *                                    after which the onFailure callback is called. The presence of
+			 *                                    a timeout does not prevent the onSuccess callback from being
+			 *                                    called when the unsubscribe completes
+			 * @throws {InvalidState} if the client is not in connected state.
+			 */
 			this.unsubscribe = function (filter, unsubscribeOptions) {
 				if (typeof filter !== "string" && filter.constructor !== Array)
-					throw new Error("Invalid argument:"+filter);
-				unsubscribeOptions = unsubscribeOptions || {} ;
-				validate(unsubscribeOptions,  {invocationContext:"object",
-					onSuccess:"function",
-					onFailure:"function",
-					timeout:"number"
+					throw new Error("Invalid argument:" + filter);
+				unsubscribeOptions = unsubscribeOptions || {};
+				validate(unsubscribeOptions, {
+					invocationContext: "object",
+					onSuccess: "function",
+					onFailure: "function",
+					timeout: "number"
 				});
 				if (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure)
 					throw new Error("unsubscribeOptions.timeout specified with no onFailure callback.");
@@ -2141,29 +2142,29 @@ function onMessageArrived(message) {
 		 *                     and the subscrption was made after the message has been published.
 		 * @throws {InvalidState} if the client is not connected.
 		 */
-			this.send = function (topic,payload,qos,retained) {
-				var message ;
+			this.send = function (topic, payload, qos, retained) {
+				var message;
 
-				if(arguments.length === 0){
-					throw new Error("Invalid argument."+"length");
+				if (arguments.length === 0) {
+					throw new Error("Invalid argument." + "length");
 
-				}else if(arguments.length == 1) {
+				} else if (arguments.length == 1) {
 
 					if (!(topic instanceof Message) && (typeof topic !== "string"))
-						throw new Error("Invalid argument:"+ typeof topic);
+						throw new Error("Invalid argument:" + typeof topic);
 
 					message = topic;
 					if (typeof message.destinationName === "undefined")
-						throw new Error(format(ERROR.INVALID_ARGUMENT,[message.destinationName,"Message.destinationName"]));
+						throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, "Message.destinationName"]));
 					client.send(message);
 
-				}else {
-				//parameter checking in Message object
+				} else {
+					//parameter checking in Message object
 					message = new Message(payload);
 					message.destinationName = topic;
-					if(arguments.length >= 3)
+					if (arguments.length >= 3)
 						message.qos = qos;
-					if(arguments.length >= 4)
+					if (arguments.length >= 4)
 						message.retained = retained;
 					client.send(message);
 				}
@@ -2192,29 +2193,29 @@ function onMessageArrived(message) {
 		 *                     and the subscrption was made after the message has been published.
 		 * @throws {InvalidState} if the client is not connected.
 		 */
-			this.publish = function(topic,payload,qos,retained) {
-				var message ;
+			this.publish = function (topic, payload, qos, retained) {
+				var message;
 
-				if(arguments.length === 0){
-					throw new Error("Invalid argument."+"length");
+				if (arguments.length === 0) {
+					throw new Error("Invalid argument." + "length");
 
-				}else if(arguments.length == 1) {
+				} else if (arguments.length == 1) {
 
 					if (!(topic instanceof Message) && (typeof topic !== "string"))
-						throw new Error("Invalid argument:"+ typeof topic);
+						throw new Error("Invalid argument:" + typeof topic);
 
 					message = topic;
 					if (typeof message.destinationName === "undefined")
-						throw new Error(format(ERROR.INVALID_ARGUMENT,[message.destinationName,"Message.destinationName"]));
+						throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, "Message.destinationName"]));
 					client.send(message);
 
-				}else {
+				} else {
 					//parameter checking in Message object
 					message = new Message(payload);
 					message.destinationName = topic;
-					if(arguments.length >= 3)
+					if (arguments.length >= 3)
 						message.qos = qos;
-					if(arguments.length >= 4)
+					if (arguments.length >= 4)
 						message.retained = retained;
 					client.send(message);
 				}
@@ -2262,7 +2263,7 @@ function onMessageArrived(message) {
 				client.stopTrace();
 			};
 
-			this.isConnected = function() {
+			this.isConnected = function () {
 				return client.connected;
 			};
 		};
@@ -2303,9 +2304,9 @@ function onMessageArrived(message) {
 	 */
 		var Message = function (newPayload) {
 			var payload;
-			if (   typeof newPayload === "string" ||
-		newPayload instanceof ArrayBuffer ||
-		(ArrayBuffer.isView(newPayload) && !(newPayload instanceof DataView))
+			if (typeof newPayload === "string" ||
+				newPayload instanceof ArrayBuffer ||
+				(ArrayBuffer.isView(newPayload) && !(newPayload instanceof DataView))
 			) {
 				payload = newPayload;
 			} else {
@@ -2317,19 +2318,19 @@ function onMessageArrived(message) {
 			var retained = false;
 			var duplicate = false;
 
-			Object.defineProperties(this,{
-				"payloadString":{
-					enumerable : true,
-					get : function () {
+			Object.defineProperties(this, {
+				"payloadString": {
+					enumerable: true,
+					get: function () {
 						if (typeof payload === "string")
 							return payload;
 						else
 							return parseUTF8(payload, 0, payload.length);
 					}
 				},
-				"payloadBytes":{
+				"payloadBytes": {
 					enumerable: true,
-					get: function() {
+					get: function () {
 						if (typeof payload === "string") {
 							var buffer = new ArrayBuffer(UTF8Length(payload));
 							var byteStream = new Uint8Array(buffer);
@@ -2341,45 +2342,45 @@ function onMessageArrived(message) {
 						}
 					}
 				},
-				"destinationName":{
+				"destinationName": {
 					enumerable: true,
-					get: function() { return destinationName; },
-					set: function(newDestinationName) {
+					get: function () { return destinationName; },
+					set: function (newDestinationName) {
 						if (typeof newDestinationName === "string")
 							destinationName = newDestinationName;
 						else
 							throw new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, "newDestinationName"]));
 					}
 				},
-				"qos":{
+				"qos": {
 					enumerable: true,
-					get: function() { return qos; },
-					set: function(newQos) {
-						if (newQos === 0 || newQos === 1 || newQos === 2 )
+					get: function () { return qos; },
+					set: function (newQos) {
+						if (newQos === 0 || newQos === 1 || newQos === 2)
 							qos = newQos;
 						else
-							throw new Error("Invalid argument:"+newQos);
+							throw new Error("Invalid argument:" + newQos);
 					}
 				},
-				"retained":{
+				"retained": {
 					enumerable: true,
-					get: function() { return retained; },
-					set: function(newRetained) {
+					get: function () { return retained; },
+					set: function (newRetained) {
 						if (typeof newRetained === "boolean")
 							retained = newRetained;
 						else
 							throw new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, "newRetained"]));
 					}
 				},
-				"topic":{
+				"topic": {
 					enumerable: true,
-					get: function() { return destinationName; },
-					set: function(newTopic) {destinationName=newTopic;}
+					get: function () { return destinationName; },
+					set: function (newTopic) { destinationName = newTopic; }
 				},
-				"duplicate":{
+				"duplicate": {
 					enumerable: true,
-					get: function() { return duplicate; },
-					set: function(newDuplicate) {duplicate=newDuplicate;}
+					get: function () { return duplicate; },
+					set: function (newDuplicate) { duplicate = newDuplicate; }
 				}
 			});
 		};
@@ -2389,7 +2390,7 @@ function onMessageArrived(message) {
 			Client: Client,
 			Message: Message
 		};
-	// eslint-disable-next-line no-nested-ternary
+		// eslint-disable-next-line no-nested-ternary
 	})(typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
 	return PahoMQTT;
 });
